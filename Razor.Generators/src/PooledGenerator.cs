// Licensed to the Razor contributors under one or more agreements.
// The Razor project licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using JetBrains.Annotations;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Razor.Generators;

[PublicAPI]
[Generator]
public sealed class PooledGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var candidates = context
            .SyntaxProvider.CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax { AttributeLists.Count: > 0 },
                static (ctx, _) => GetPooledClassSymbol(ctx)
            )
            .Where(static s => s is not null);

        var compilationAndClasses = context.CompilationProvider.Combine(candidates.Collect());
        context.RegisterSourceOutput(
            compilationAndClasses,
            static (spc, pair) =>
            {
                var (_, classes) = pair;
                var seen = new HashSet<string>();

                foreach (var cls in Enumerable.OfType<INamedTypeSymbol>(classes))
                {
                    ProcessClass(spc, cls, seen);
                }
            }
        );
    }

    private static string GenerateObjectPoolPartial(
        string? ns,
        string typeName,
        string accessModifier
    )
    {
        var nSpaceOpen = ns is null ? string.Empty : $"namespace {ns}";
        return $$"""
            // <auto-generated />
            #nullable enable
            using Microsoft.Extensions.ObjectPool;
            using Razor.Attributes;
            using Razor.Generics;

            {{nSpaceOpen}};

            {{accessModifier}} partial class {{typeName}}
            {
                private static readonly ObjectPool<{{typeName}}> s_pool = new DefaultObjectPool<{{typeName}}>(new __{{typeName}}Policy());

                public static {{typeName}} Rent()
                {
                    var obj = s_pool.Get();
                    return obj;
                }

                public static void Return({{typeName}} obj)
                {
                    s_pool.Return(obj);
                }
                
                public static SafeLease Lease(out {{typeName}} instance)
                {
                    var obj = Rent();
                    instance = obj;
                    return new SafeLease(obj);
                }
                
                public struct SafeLease : IDisposable
                {
                    private {{typeName}}? _instance;

                    public {{typeName}} Instance => _instance ?? throw new ObjectDisposedException(typeof({{typeName}}).Name);

                    public void Dispose()
                    {
                        var inst = Interlocked.Exchange(ref _instance, null);
                        if (inst is not null)
                        {
                            Return(inst);
                        }
                    }
                
                    internal SafeLease({{typeName}} instance)
                    {
                        return _instance = instance;
                    }
                }

                private sealed class __{{typeName}}Policy : PooledObjectPolicy<{{typeName}}>
                {
                    public override {{typeName}} Create()
                    {
                        return new {{typeName}}();
                    }

                    public override bool Return({{typeName}} obj)
                    {
                        if (obj is IPooledResettable r)
                        {
                            r.Reset();
                        }

                        return true; // keep in pool
                    }
                }
            }
            """;
    }

    private static bool HasPooledAttribute(INamedTypeSymbol symbol)
    {
        return symbol
            .GetAttributes()
            .Any(a => a.AttributeClass?.ToDisplayString() == "Razor.Attributes.PooledAttribute");
    }

    private static INamedTypeSymbol? GetPooledClassSymbol(GeneratorSyntaxContext ctx)
    {
        if (ctx.Node is not ClassDeclarationSyntax cds)
        {
            return null;
        }

        if (
            ModelExtensions.GetDeclaredSymbol(ctx.SemanticModel, cds) is not INamedTypeSymbol symbol
        )
        {
            return null;
        }

        return HasPooledAttribute(symbol) ? symbol : null;
    }

    private static bool IsPartial(INamedTypeSymbol cls)
    {
        return cls.DeclaringSyntaxReferences.Any(r =>
            r.GetSyntax() is ClassDeclarationSyntax cds
            && cds.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword))
        );
    }

    private static void ReportNotPartial(SourceProductionContext spc, INamedTypeSymbol cls)
    {
        var descriptor = new DiagnosticDescriptor(
            id: "POOLED",
            title: "Class must be partial",
            messageFormat: "Class '{0}' must be declared partial to use [Pooled]",
            category: "Pooled",
            DiagnosticSeverity.Error,
            isEnabledByDefault: true
        );

        spc.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None, cls.ToDisplayString()));
    }

    private static string? GetNamespace(INamedTypeSymbol cls)
    {
        return cls.ContainingNamespace.IsGlobalNamespace
            ? null
            : cls.ContainingNamespace.ToDisplayString();
    }

    private static string BuildHint(string? ns, string typeName)
    {
        return $"{(ns is null ? string.Empty : $"{ns}.")}{typeName}.Pooled.g.cs";
    }

    private static string GetAccessModifier(Accessibility accessibility)
    {
        return accessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Protected => "protected",
            Accessibility.Private => "private",
            Accessibility.ProtectedOrInternal => "protected internal",
            Accessibility.ProtectedAndInternal => "private protected",
            _ => "internal",
        };
    }

    private static void ProcessClass(
        SourceProductionContext spc,
        INamedTypeSymbol cls,
        HashSet<string> seen
    )
    {
        if (!IsPartial(cls))
        {
            ReportNotPartial(spc, cls);
            return;
        }

        var ns = GetNamespace(cls);
        var typeName = cls.Name;
        var fullHint = BuildHint(ns, typeName);

        if (!seen.Add(fullHint))
        {
            return;
        }

        var accessModifier = GetAccessModifier(cls.DeclaredAccessibility);
        var code = GenerateObjectPoolPartial(ns, typeName, accessModifier);
        spc.AddSource(fullHint, code);
    }
}
